# From PHP to Rust: Migrating a REST API between this two languages. (Part I)

## Disclaimer

After beginning, I need to say that I a `huge fan` of `PHP` for several years from today, which not only allows me to create great applications but also keeps the food on my table &lt;3.

However, `Rust` is gaining traction among the developer community, not for nothing was awarded as the `most loved` programming language in `the last 7 years` in `Stackoverflow's Developer Survey` ([details here](https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages)), and I wanted to try how difficult is for a `PHP` developer to learn `Rust` with a practical example, the migration of a single endpoint API web application from `PHP` to `Rust`.

## What's RUST Language

Originally thought of as `C-Language` replacement, `Rust` rapidly evolve not only to build system software `(operating systems, IoT, and AI)` and, along with his big community, web frameworks begin to grow in the ecosystem.

Why `Rust`:

* Blazingly fast and memory-efficient: with no runtime or garbage collector, it can power performance-critical services
    
* A strong type system and ownership model that guarantees memory-safety and thread-safety programming, enabling you to eliminate many classes of bugs at compile-time
    
* Great documentation, a friendly compiler with useful error messages, top-notch tooling and much more.
    

His most know web framework is called `Actix-Web` ([more here](https://actix.rs)) , and it is considered one of the `most performant web frameworks available in the market`, capable of serving `552K requests per second`, compared with many others in multiple languages. [(the benchmark can be viewed here)](https://www.techempower.com/benchmarks/#section=data-r21&hw=ph&test=fortune)

## The Application

If you read my previous blog post, I always have a `"demo application"` to use in all my tutorials, the `"Availability API"`, this application is far simple but it contains the implementation of the minimum web application nowadays (Rest API, DB Access, Hexagonal Architecture design, etc).

[![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671720082853/98221f94-6c2b-4b4f-90a3-797c10c0568f.jpeg align="center")](https://cdn.hashnode.com/res/hashnode/image/upload/v1658159844888/jAGpW1FPk.png?auto=compress,format&format=webp)

The architecture of the infrastructure is not important here, but, since we use a k8s cluster agnostic from the application we can reuse it here for demonstration purposes.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671720274056/6f21946a-e966-4131-aaeb-50e27f9a1364.png align="center")

## The Migration

As the first step, we want to write, the web server (or configure the web server with the `actix-web framework`), set the `routing`, and the `controller` to receive the input body request and response with the same as the `response` `body`.

### File Structures

As we spoke, the `availabiity-api` was designed with hexagonal architecture in mind, so we want to reach the same goal in the `Rust` implementations, let's see how it's compared.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671723718440/9ab0c71a-f156-4f1b-8853-2df3b8e937d0.jpeg align="center")

### Rust `main` entrypoint

As the bootstrap for `PHP`, you have the `main.rs` file, who has a `main()` function, mandatory for any `Rust` application to work (like `Java` or `Typescript` Main)

Here how my `main.rs` the file looks like, also, remember, that I was using `actix-web` framework, so we have the `"bootstrapping"` of the web server through `actix-web` framework.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671724105096/290b724d-6ebf-430f-b3c7-1bd4d40bd51c.png align="center")

And then, the `availability-controller`, asks for availability in a 3rd party external `API` or a `database`.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671724442187/339489d0-51d4-4b2d-8162-5fc2861b3671.png align="center")

Note that `PropertyAvailabilityRequest` is a `DTO` with a series of `ValueObject` that validates itself, so, in case of an invalid `request` `body`, and serialized `JSON` error is returned to the client.

### Compile and Run

Now let's compile and try to run this first step:

```bash
cargo build && cargo run
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671725674114/9899be12-71c5-45e4-809b-4ddc77af9ad4.png align="center")

Now we're ready to test our first very basic endpoint, the response must be equal to the request that we send to the API.

```bash
curl --location --request POST 'http://localhost:8080/v1/property/availability' \
--header 'Content-Type: application/vnd.api+json' \
--header 'Accept: application/vnd.api+json' \
--data-raw '{
  "requestDates": {
    "checkin": "1956-06-29T02:09:38.752Z",
    "checkout": "1977-01-17T15:39:47.465Z"
  },
  "pax": [
    {
      "adults": 2,
      "childs": 1
    }
  ]
}'
```

And (at least for this first part) how, we can migrate an endpoint from `PHP` to `Rust`. We have a lot of work to do, regarding, database connection, event dispatching and other kinds of stuff.

By now, we have a simple endpoint that returns the same request body as the response body, in the next chapter we need to add some kind of middleware to add custom headers, database connection and so on.

Thanks for reading!

## Support Me

If you like what you just read and you find it valuable, then you can buy me a coffee by clicking the link in the image below.

%%\[buy-me-a-coffee\]